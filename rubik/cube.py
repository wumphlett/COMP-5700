from collections import Counter, OrderedDict
from math import sqrt
import random
from typing import Any, List, Tuple


"""
This is the mapping of normal vectors to the cube's faces and how each face is referred to.
The face names and rotation chars (assuming the chars are unique) are able to be changed at will.
"""
FACES = OrderedDict(
    [
        ("y_pos", {"rotation": "f", "method": "_front", "name": "front"}),
        ("x_pos", {"rotation": "r", "method": "_right", "name": "right"}),
        ("y_neg", {"rotation": "b", "method": "_back", "name": "back"}),
        ("x_neg", {"rotation": "l", "method": "_left", "name": "left"}),
        ("z_pos", {"rotation": "u", "method": "_up", "name": "up"}),
        ("z_neg", {"rotation": "d", "method": "_down", "name": "down"}),
    ]
)

"""
Autogenerated mapping of rotation char to attributes of the face they point to.
"""
ROTATIONS = {face["rotation"]: {"normal": normal, "method": face["method"]} for normal, face in FACES.items()}

"""
The side faces of the cube
"""
SIDES = list(FACES.keys())[:4]


class Cubelet:
    """A class representing the cubelets that compose a rubik's cube."""

    def __init__(self):
        self.x_pos = self.x_neg = self.y_pos = self.y_neg = self.z_pos = self.z_neg = ""

    def __repr__(self) -> str:
        """A print out of the cubelet for debugging purposes."""
        return f"({', '.join(f'{key}: [{getattr(self, key)}]' for key in FACES.keys())})"

    def sticker(self, normal: str) -> str:
        """Obtain a sticker of the cubelet given a normal vector."""
        return getattr(self, normal)

    def rotate(self, normal: str, clockwise: bool) -> "Cubelet":
        """Rotate the stickers of the cubelet given a normal vector and whether the rotation is clockwise."""
        clockwise = clockwise if (normal.split("_")[1] == "pos") ^ (normal.split("_")[0] == "z") else not clockwise
        rotation_order = [
            edge for edge in ("x_neg", "z_neg", "y_neg", "x_pos", "z_pos", "y_pos") if not edge.startswith(normal[0])
        ][:: 1 if clockwise else -1]
        swap = self.sticker(rotation_order[0])
        for i in range(4):
            setattr(self, rotation_order[i], self.sticker(rotation_order[i + 1]) if i != 3 else swap)
        return self


class CubeletWrapper:
    """A class that wraps a cubelet. This is done so you can follow a cubelet as it moves around the cube."""

    def __init__(self):
        self.cubelet = Cubelet()

    def __getattr__(self, item: str):
        """Obtain properties of the wrapped cubelet over properties of the wrapper itself."""
        return getattr(self.cubelet, item)

    def __setattr__(self, key: str, value: Any):
        """Set properties of the wrapped cubelet over properties of the wrapper itself."""
        if key != "cubelet":
            setattr(self.cubelet, key, value)
        else:
            self.__dict__["cubelet"] = value

    def __repr__(self):
        """A print out of the wrapped cubelet for debugging purposes."""
        return repr(self.cubelet)


class Cube:
    """A class representing a rubik's cube.

    Cube can represent any nth rubik's cube, meaning you can have a 3x3 cube, 5x5 cube, etc.
    The degree of the rubik's cube is determined from the input string, where (n^2) * 6 = len(input_string)

    Attributes:
        n (int): Which nth rubik's cube is represented. e.g. if n = 3 then one side of the cube is a 3x3 square.

    Notes:
        The cube is defined along the x, y, and z axis. If you were looking at the corner of the rubik's cube that joins
        the front, right, and top faces, the x-axis would extend normal to the right face, the y-axis normal to the
        front, and z-axis normal to the top.

        The cube's "stickers" are instantiated in a particular order given the input string. Each face of the cube will
        be written from left to right, top to bottom, and the faces in order of front, right, back, left, up, down.
        So, the first character in the input string will be the top left sticker of the front face, etc. etc.
    """

    def __init__(self, cube_str: str):
        self.n = int(sqrt(len(cube_str) // 6))
        self._cube = [[[CubeletWrapper() for _ in range(self.n)] for _ in range(self.n)] for _ in range(self.n)]

        for offset, (normal, face) in enumerate(FACES.items()):
            face, offset = self._face(normal), self.n**2 * offset
            for i in range(self.n**2):
                setattr(face[i // self.n][i % self.n], normal, cube_str[i + offset])

    def __str__(self) -> str:
        """The one-line string representation of the cube."""
        return "".join(
            "".join(sticker for row in self._face_stickers(normal) for sticker in row) for normal in FACES.keys()
        )

    def __repr__(self) -> str:
        """A print out of the cube's faces for debugging purposes."""
        result = ""
        for normal, face in FACES.items():
            result += f"\n\n{face['name'].upper()}\n"
            result += "\n".join(str(row) for row in self._face_stickers(normal))
        return result

    def rotate(self, face: str, offset: int = 0, rotations: int = 1) -> str:
        """Rotate a layer of the cube given the face you're looking at, an offset from that face, and # of rotations."""
        if not ROTATIONS.get(face.lower()):
            raise ValueError("The face specified for rotation is not present in " + str(list(ROTATIONS.keys())))
        if offset < 0 or offset >= self.n:
            raise ValueError(f"The offset specified must be between 0 <= offset < {self.n}")
        if rotations < 0:
            raise ValueError("The number of rotations specified must be greater than 0")

        normal = ROTATIONS[face.lower()]["normal"]
        layer = self._face(normal, offset)
        clockwise = face.isupper()

        for _ in range(rotations):
            for x in range(0, self.n // 2):
                for y in range(x, self.n - x - 1):
                    # fmt: off
                    swap = layer[x][y].rotate(normal, clockwise)
                    if clockwise:
                        layer[x][y].cubelet = layer[self.n-y-1][x].rotate(normal, clockwise)
                        layer[self.n-y-1][x].cubelet = layer[self.n-x-1][self.n-y-1].rotate(normal, clockwise)
                        layer[self.n-x-1][self.n-y-1].cubelet = layer[y][self.n-x-1].rotate(normal, clockwise)
                        layer[y][self.n-x-1].cubelet = swap
                    else:
                        layer[x][y].cubelet = layer[y][self.n-x-1].rotate(normal, clockwise)
                        layer[y][self.n-x-1].cubelet = layer[self.n-x-1][self.n-y-1].rotate(normal, clockwise)
                        layer[self.n-x-1][self.n-y-1].cubelet = layer[self.n-y-1][x].rotate(normal, clockwise)
                        layer[self.n-y-1][x].cubelet = swap
                    # fmt: on
        return f"{offset if offset != 0 else ''}{face}" * rotations

    def scramble(self, rotations: int = 20):
        """Scramble the cube randomly given a number of random rotations."""
        chars = list(ROTATIONS.keys())
        for _ in range(rotations):
            self.rotate(random.choice(chars), offset=random.randint(0, self.n // 2 - 1), rotations=random.randint(1, 3))

    def solve(self) -> str:
        """Perform rotations on the cube to solve it."""
        if self.n != 3:
            raise ValueError("solve() is only defined for cubes of the 3rd degree")

        return self._simplify(self._top_layer())

    @staticmethod
    def _simplify(solution: str) -> str:
        """Simplifies a string of rotations into a shorter, equivalent solution string."""
        result, i = "", 0
        while i < len(solution):
            if i + 3 < len(solution) and len(Counter(solution[i : i + 4])) == 1:
                i += 4
            elif i + 2 < len(solution) and len(Counter(solution[i : i + 3])) == 1:
                result += solution[i].upper() if solution[i].islower() else solution[i].lower()
                i += 3
            else:
                result += solution[i]
                i += 1
        return result

    def _top_layer(self) -> str:
        """Perform rotations on the cube to make the top layer."""
        result = ""
        if self.is_solved():
            return result
        if not self.is_top_cornered():
            result = self._top_corners()

        middles = [self._up()[y][x].cubelet for y, x in ((0, 1), (1, 0), (1, 2), (2, 1))]
        while not self.is_solved():
            middle = next((middle for middle in middles if self._is_cubelet_solved(middle)), None)
            normal = self._next_normal(
                next(normal for normal in SIDES if middle.sticker(normal)) if middle else "y_neg", 2
            )
            left, mid, right, up = self._perspective(normal)
            FFUrLFFlRUFF = (
                mid.upper()
                + mid.upper()
                + up.upper()
                + right
                + left.upper()
                + mid.upper()
                + mid.upper()
                + left
                + right.upper()
                + up.upper()
                + mid.upper()
                + mid.upper()
            )
            result += "".join(self.rotate(rotation) for rotation in FFUrLFFlRUFF)
        return result

    def _top_corners(self) -> str:
        """Perform rotations on the cube to make the top corners."""
        result = ""
        if self.is_top_cornered():
            return result
        if not self.is_top_surfaced():
            result = self._top_surface()

        corners = [self._up()[y][x].cubelet for y, x in ((0, 0), (0, 2), (2, 0), (2, 2))]

        while not all(self._is_cubelet_solved(corner) for corner in corners):
            normal = next(
                (normal for normal in SIDES if self._sticker(0, 0, normal) == self._sticker(0, 2, normal)), None
            )
            # pair of solved corners
            if normal:
                while self._sticker(0, 0, normal) != self._color(normal):
                    result += self.rotate(FACES["z_pos"]["rotation"])
                    normal = self._next_normal(normal)
            # no pair of solved corners
            else:
                normal = "x_neg"  # inconsequential value, just need a default for if there are no solved corner pairs
            normal = self._next_normal(normal)
            left, mid, right, up = self._perspective(normal)
            lURuLUr = left + up.upper() + right.upper() + up + left.upper() + up.upper() + right
            RUrURUUr = right.upper() + up.upper() + right + up.upper() + right.upper() + up.upper() + up.upper() + right
            result += "".join(self.rotate(rotation) for rotation in lURuLUr)  # solve corners, creates the fish
            result += "".join(self.rotate(rotation) for rotation in RUrURUUr)  # solve the fish
        return result

    def _top_surface(self) -> str:
        """Perform rotations on the cube to make the top surface."""
        result = ""
        if self.is_top_surfaced():
            return result
        if not self.is_top_crossed():
            result = self._top_cross()

        RUrURUUr = (
            FACES["x_pos"]["rotation"].upper()
            + FACES["z_pos"]["rotation"].upper()
            + FACES["x_pos"]["rotation"]
            + FACES["z_pos"]["rotation"].upper()
            + FACES["x_pos"]["rotation"].upper()
            + FACES["z_pos"]["rotation"].upper()
            + FACES["z_pos"]["rotation"].upper()
            + FACES["x_pos"]["rotation"]
        )
        corners = [self._up()[y][x].cubelet for y, x in ((0, 0), (0, 2), (2, 0), (2, 2))]

        # all correct top pieces
        if all(piece.sticker("z_pos") == self._color("z_pos") for piece in corners):
            return result
        # no correct top pieces
        if not any(piece.sticker("z_pos") == self._color("z_pos") for piece in corners):
            while self._sticker(0, 2, "x_neg") != self._color("z_pos"):
                result += self.rotate(FACES["z_pos"]["rotation"])
            result += "".join(self.rotate(rotation) for rotation in RUrURUUr)
        # at least one correct corner
        while not all(piece.sticker("z_pos") == self._color("z_pos") for piece in corners):
            # 2+ correct corners
            if len([piece for piece in corners if piece.sticker("z_pos") == self._color("z_pos")]) > 1:
                while self._sticker(0, 0, "y_pos") != self._color("z_pos"):
                    result += self.rotate(FACES["z_pos"]["rotation"])
            # 1 correct corner (fish)
            else:
                while self._sticker(2, 0, "z_pos") != self._color("z_pos"):
                    result += self.rotate(FACES["z_pos"]["rotation"])
            result += "".join(self.rotate(rotation) for rotation in RUrURUUr)
        return result

    def _top_cross(self) -> str:
        """Perform rotations on the cube to make the top cross."""
        result = ""
        if self.is_top_crossed():
            return result
        if not self.is_middle_layered():
            result = self._middle_layer()

        FURurf = (
            FACES["y_pos"]["rotation"].upper()
            + FACES["z_pos"]["rotation"].upper()
            + FACES["x_pos"]["rotation"].upper()
            + FACES["z_pos"]["rotation"]
            + FACES["x_pos"]["rotation"]
            + FACES["y_pos"]["rotation"]
        )
        cross = [self._up()[y][x].cubelet for y, x in ((0, 1), (1, 0), (1, 2), (2, 1))]

        # all correct top pieces
        if all(piece.sticker("z_pos") == self._color("z_pos") for piece in cross):
            return result
        # no correct top pieces
        if not any(piece.sticker("z_pos") == self._color("z_pos") for piece in cross):
            result += "".join(self.rotate(rotation) for rotation in FURurf)
        # vertical bar
        if all(self._sticker(y, x, "z_pos") == self._color("z_pos") for y, x in ((0, 1), (2, 1))):
            result += "".join(self.rotate(rotation) for rotation in FURurf)
        # horizontal bar
        elif all(self._sticker(y, x, "z_pos") == self._color("z_pos") for y, x in ((1, 0), (1, 2))):
            result += self.rotate(FACES["z_pos"]["rotation"]) + "".join(self.rotate(rotation) for rotation in FURurf)
        # 9 & 12 o'clock top color L
        while not all(self._sticker(y, x, "z_pos") == self._color("z_pos") for y, x in ((0, 1), (1, 0))):
            result += self.rotate(FACES["z_pos"]["rotation"])
        result += "".join(self.rotate(rotation) for rotation in FURurf)
        return result

    def _middle_layer(self) -> str:
        """Perform rotations on the cube to make the middle layer."""
        result = ""
        if self.is_middle_layered():
            return result
        if not self.is_bottom_layered():
            result = self._bottom_layer()

        middles = set()
        for normal in list(FACES.keys())[:5]:
            face = self._face(normal)
            for y, x in ((1, 0), (0, 1), (1, 2)):
                if self._color("z_pos") not in [face[y][x].sticker(normal) for normal in FACES.keys()]:
                    middles.add(face[y][x].cubelet)
        middles = list(middles)

        while True:
            misplaced_middles = [middle for middle in middles if not self._is_cubelet_solved(middle)]

            if not misplaced_middles:
                break
            for corner in misplaced_middles:
                result += self._middle_piece(corner)
        return result

    def _middle_piece(self, middle: "Cubelet") -> str:
        """Perform rotations on the cube to move a middle piece in to place."""
        result = ""
        if self._is_cubelet_solved(middle):
            return result

        if not middle.sticker("z_pos"):
            normal = next(normal for normal in SIDES if middle.sticker(normal))
            result += self._trigger(normal, bool(middle.sticker(self._next_normal(normal)))) + self._bottom_layer()

        normal = next(normal for normal in SIDES if middle.sticker(normal))
        while middle.sticker(normal) != self._color(normal):
            result += self.rotate(FACES["z_pos"]["rotation"])
            normal = self._next_normal(normal)
        right = middle.sticker("z_pos") == self._color(self._next_normal(normal))
        result += self.rotate(FACES["z_pos"]["rotation"].upper()) if right else self.rotate(FACES["z_pos"]["rotation"])
        result += self._trigger(normal, right) + self._bottom_layer()
        return result

    def _bottom_layer(self) -> str:
        """Perform rotations on the cube to make the bottom layer."""
        result = ""
        if self.is_bottom_layered():
            return result
        if not self.is_bottom_crossed():
            result = self._bottom_cross()

        corners = []
        for normal in FACES.keys():
            face = self._face(normal)
            for y, x in ((0, 0), (0, 2), (2, 0), (2, 2)):
                if face[y][x].sticker(normal) == self._color("z_neg"):
                    corners.append(face[y][x].cubelet)

        while True:
            misplaced_corners = [corner for corner in corners if not self._is_cubelet_solved(corner)]

            if not misplaced_corners:
                break
            for corner in misplaced_corners:
                result += self._bottom_corner(corner)
        return result

    def _bottom_corner(self, corner: "Cubelet") -> str:
        """Perform rotations on the cube to move a bottom corner in to place."""
        result = ""
        normal = next(
            normal
            for normal in SIDES
            if corner.sticker(normal) == self._color("z_neg")
            or (corner.sticker(normal) and self._color("z_neg") in (corner.sticker("z_neg"), corner.sticker("z_pos")))
        )
        right = bool(corner.sticker(self._next_normal(normal)))

        if self._is_cubelet_solved(corner):
            return result
        if corner.sticker("z_neg") not in ("", self._color("z_neg")):  # bottom row
            result += self._trigger(normal, right)
            right = not right
        if corner.sticker("z_pos") == self._color("z_neg"):  # top face
            result += self._trigger(normal, right, 2)
            right = not right
        if corner.sticker("z_neg") == self._color("z_neg"):  # bottom face
            result += self._trigger(normal, right)
        if corner.sticker("z_pos") not in ("", self._color("z_neg")):  # top row
            normal = next(normal for normal in SIDES if corner.sticker(normal) not in ("", self._color("z_neg")))
            right = bool(corner.sticker(self._next_normal(normal)))
            while self._color(normal) != corner.sticker(normal):
                result += self.rotate(FACES["z_pos"]["rotation"])
                normal = self._next_normal(normal)
            result += self._trigger(normal, right)
        return result

    def _trigger(self, normal: str, is_right: bool, rotations: int = 1) -> str:
        """Perform rotations on the cube to make a trigger."""
        result = ""
        left, mid, right, up = self._perspective(normal)
        if is_right:
            result += self.rotate(right.upper())
            for _ in range(rotations):
                result += self.rotate(up.upper())
            result += self.rotate(right)
        else:
            result += self.rotate(left)
            for _ in range(rotations):
                result += self.rotate(up)
            result += self.rotate(left.upper())
        return result

    def _bottom_cross(self) -> str:
        """Perform rotations on the cube to make the bottom cross."""
        if self.is_bottom_crossed():
            return ""

        result = self._daisy()

        petals = []
        for y, x in ((0, 1), (1, 0), (1, 2), (2, 1)):
            petals.append(self._up()[y][x].cubelet)

        for petal in petals:
            normal = next(normal for normal in SIDES if petal.sticker(normal))
            while self._color(normal) != petal.sticker(normal):
                result += self.rotate(FACES["z_pos"]["rotation"])
                normal = self._next_normal(normal)
            result += self.rotate(FACES[normal]["rotation"]) + self.rotate(FACES[normal]["rotation"])
        return result

    def _daisy(self) -> str:
        """Perform rotations on the cube to make the daisy."""
        petals = []
        for normal in FACES.keys():
            face = self._face(normal)
            for y, x in ((0, 1), (1, 0), (1, 2), (2, 1)):
                if face[y][x].sticker(normal) == self._color("z_neg") and face[y][x].sticker("z_pos") != self._color(
                    "z_neg"
                ):
                    petals.append(face[y][x].cubelet)

        result = ""
        for petal in petals:
            # petal on the top/bottom of a side face
            if any(petal.sticker(normal) not in ("", self._color("z_neg")) for normal in list(FACES.keys())[4:]):
                normal = next(normal for normal in SIDES if petal.sticker(normal) == self._color("z_neg"))
                while self._face(normal)[0][1].sticker("z_pos") == self._color("z_neg"):
                    result += self.rotate(FACES["z_pos"]["rotation"])
                left, mid, right, up = self._perspective(normal)
                if petal.sticker("z_pos"):  # top
                    result += self.rotate(mid) + self.rotate(up.upper()) + self.rotate(left) + self.rotate(up)
                else:  # bottom
                    result += self.rotate(mid) + self.rotate(up) + self.rotate(right.upper()) + self.rotate(up.upper())
            # petal on an edge face
            else:
                normal = next(normal for normal in SIDES if petal.sticker(normal) not in ("", self._color("z_neg")))
                while self._face(normal)[0][1].sticker("z_pos") == self._color("z_neg"):
                    result += self.rotate(FACES["z_pos"]["rotation"])
                while petal.sticker("z_pos") != self._color("z_neg"):
                    result += self.rotate(FACES[normal]["rotation"])
        return result

    @staticmethod
    def _perspective(normal) -> Tuple[str, str, str, str]:
        """Find the left, mid, right, and up rotation chars relative from a side face of the cube."""
        return (
            FACES[list(FACES.keys())[(list(FACES.keys()).index(normal) + 3) % 4]]["rotation"],
            FACES[normal]["rotation"],
            FACES[list(FACES.keys())[(list(FACES.keys()).index(normal) + 1) % 4]]["rotation"],
            FACES["z_pos"]["rotation"],
        )

    def is_solved(self) -> bool:
        """Check if the cube is solved."""
        for normal in FACES.keys():
            for sticker in (sticker for row in self._face_stickers(normal) for sticker in row):
                if sticker != self._color(normal):
                    return False
        return True

    def is_top_cornered(self) -> bool:
        """Check if the cube is top cornered."""
        if self.n != 3:
            raise ValueError("is_top_cornered() is only defined for cubes of the 3rd degree")

        if not self.is_top_surfaced():
            return False
        for normal in SIDES:
            if not all(self._sticker(y, x, normal) == self._color(normal) for y, x in ((0, 0), (2, 0))):
                return False
        return True

    def is_top_surfaced(self) -> bool:
        """Check if the cube is top surfaced."""
        if self.n != 3:
            raise ValueError("is_top_surfaced() is only defined for cubes of the 3rd degree")

        if not self.is_middle_layered():
            return False
        for sticker in (sticker for row in self._face_stickers("z_pos") for sticker in row):
            if sticker != self._color("z_pos"):
                return False
        return True

    def is_top_crossed(self) -> bool:
        """Check if the cube is top crossed."""
        if self.n != 3:
            raise ValueError("is_top_crossed() is only defined for cubes of the 3rd degree")

        if not self.is_middle_layered():
            return False
        if not all(self._sticker(y, x, "z_pos") == self._color("z_pos") for y, x in ((0, 1), (1, 0), (1, 2), (2, 1))):
            return False
        return True

    def is_middle_layered(self) -> bool:
        """Check if the cube is middle layered."""
        if self.n != 3:
            raise ValueError("is_middle_layered() is only defined for cubes of the 3rd degree")

        if not self.is_bottom_layered():
            return False
        for normal in SIDES:
            if not all(sticker == self._color(normal) for sticker in self._face_stickers(normal)[1]):
                return False
        return True

    def is_bottom_layered(self) -> bool:
        """Check if the cube is bottom layered."""
        if self.n != 3:
            raise ValueError("is_bottom_layered() is only defined for cubes of the 3rd degree")

        for sticker in (sticker for row in self._face_stickers("z_neg") for sticker in row):
            if sticker != self._color("z_neg"):
                return False
        for normal in SIDES:
            if not all(sticker == self._color(normal) for sticker in self._face_stickers(normal)[2]):
                return False
        return True

    def is_bottom_crossed(self) -> bool:
        """Check if the cube is bottom crossed."""
        if self.n != 3:
            raise ValueError("is_bottom_crossed() is only defined for cubes of the 3rd degree")

        if not all(self._sticker(y, x, "z_neg") == self._color("z_neg") for y, x in ((0, 1), (1, 0), (1, 2), (2, 1))):
            return False
        for normal, face in list(FACES.items())[:4]:
            if self._sticker(2, 1, normal) != self._color(normal):
                return False
        return True

    def is_adjacency_safe(self) -> bool:
        """Check if the adjacent stickers of the edge cubelets are valid."""
        if self.n % 2 != 1:
            raise ValueError("The parity of the cube's n degree must be odd to perform an adjacency check")

        invalid_colors = {}
        for axis in "xyz":
            invalid_colors[self._color(f"{axis}_pos")] = self._color(f"{axis}_neg")
            invalid_colors[self._color(f"{axis}_neg")] = self._color(f"{axis}_pos")

        for plane in self._cube:
            for row in plane:
                for cubelet in row:
                    cubelet = set(cubelet.sticker(normal) for normal in FACES.keys())
                    for color in cubelet:
                        if color and invalid_colors.get(color) in cubelet:
                            return False
        return True

    def _color(self, normal: str) -> str:
        """Obtain the color of a face on the cube."""
        if self.n % 2 != 1:
            raise ValueError("The parity of the cube's n degree must be odd to obtain a face's color")

        return getattr(getattr(self, FACES[normal]["method"])()[self.n // 2][self.n // 2], normal)

    def _sticker(self, y: int, x: int, normal: str) -> str:
        """Obtain a sticker given a normal vector and a coordinate pair."""
        return getattr(getattr(self, FACES[normal]["method"])()[y][x], normal)

    def _face(self, normal: str, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to a normal vector."""
        return getattr(self, FACES[normal]["method"])(offset)

    def _face_stickers(self, normal: str) -> List[List[str]]:
        """Obtain a 2d array containing all the stickers for a given face."""
        return [[getattr(cubelet, normal) for cubelet in row] for row in self._face(normal)]

    @staticmethod
    def _next_normal(normal: str, jump: int = 1) -> str:
        """Obtain the side normal vector ccw to the current one if looking from the top of the cube."""
        return SIDES[(SIDES.index(normal) + jump) % 4]

    def _is_cubelet_solved(self, cubelet: "Cubelet") -> bool:
        """Test if a given cubelet is properly positioned."""
        return all(cubelet.sticker(normal) in ("", self._color(normal)) for normal in FACES.keys())

    def _front(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the front of the cube."""
        return self._xz_plane(self.n - 1 - offset)[::-1]

    def _right(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the right of the cube."""
        return [row[::-1] for row in self._yz_plane(self.n - 1 - offset)[::-1]]

    def _back(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the back of the cube."""
        return [row[::-1] for row in self._xz_plane(0 + offset)[::-1]]

    def _left(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the left of the cube."""
        return self._yz_plane(0 + offset)[::-1]

    def _up(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the top of the cube."""
        return self._xy_plane(self.n - 1 - offset)

    def _down(self, offset: int = 0) -> List[List["CubeletWrapper"]]:
        """Obtain a layer respective to the bottom of the cube."""
        return self._xy_plane(0 + offset)[::-1]

    def _xy_plane(self, z: int) -> List[List["CubeletWrapper"]]:
        """Obtain a plane parallel to the x and y axis."""
        return self._cube[z]

    def _yz_plane(self, x: int) -> List[List["CubeletWrapper"]]:
        """Obtain a plane parallel to the y and z axis."""
        return [[row[x] for row in plane] for plane in self._cube]

    def _xz_plane(self, y: int) -> List[List["CubeletWrapper"]]:
        """Obtain a plane parallel to the x and z axis."""
        return [plane[y] for plane in self._cube]


"""
BELOW IS THE IMPLEMENTATION OF RUBIK'S CUBE USING 2D ARRAYS FOR EACH FACE. THIS IS NO LONGER WHAT I'M USING FOR THE
PROJECT BUT HAS BEEN KEPT BELOW FOR RECORD KEEPING.
"""
FACE_NAMES = ("front", "right", "back", "left", "up", "down")
OPERATIONS = {name[0]: name for name in FACE_NAMES}
ADJACENT_EDGES = {
    FACE_NAMES[0]: ((42, 43, 44), (9, 12, 15), (47, 46, 45), (35, 32, 29)),
    FACE_NAMES[1]: ((44, 41, 38), (18, 21, 24), (53, 50, 47), (8, 5, 2)),
    FACE_NAMES[2]: ((38, 37, 36), (27, 30, 33), (51, 52, 53), (17, 14, 11)),
    FACE_NAMES[3]: ((36, 39, 42), (0, 3, 6), (45, 48, 51), (26, 23, 20)),
    FACE_NAMES[4]: ((20, 19, 18), (11, 10, 9), (2, 1, 0), (29, 28, 27)),
    FACE_NAMES[5]: ((6, 7, 8), (15, 16, 17), (24, 25, 26), (33, 34, 35)),
}


class Cube2D:
    def __init__(self, cube_str: str):
        self.faces = {
            face: [
                [cube_str[offset + 0], cube_str[offset + 1], cube_str[offset + 2]],
                [cube_str[offset + 3], cube_str[offset + 4], cube_str[offset + 5]],
                [cube_str[offset + 6], cube_str[offset + 7], cube_str[offset + 8]],
            ]
            for face, offset in zip(FACE_NAMES, (0, 9, 18, 27, 36, 45))
        }

    def __getitem__(self, item: int) -> str:
        return self.faces[FACE_NAMES[item // 9]][item % 9 // 3][item % 3]

    def __setitem__(self, key: int, value: str) -> None:
        self.faces[FACE_NAMES[key // 9]][key % 9 // 3][key % 3] = value

    def __repr__(self) -> str:
        result = "".join(
            f"{f[0][0]}{f[0][1]}{f[0][2]}{f[1][0]}{f[1][1]}{f[1][2]}{f[2][0]}{f[2][1]}{f[2][2]}"
            for f in (self.faces[face] for face in FACE_NAMES)
        )
        return result

    def __str__(self) -> str:
        result = "\n".join(
            face + "\n" + "\n".join(", ".join(row) for row in self.faces[face]) + "\n" for face in FACE_NAMES
        )
        return result

    def is_solved(self) -> bool:
        return all(all(self[offset] == self[offset + i] for i in range(1, 9)) for offset in (0, 9, 18, 27, 36, 45))

    def rotate(self, rotation: str) -> None:
        clockwise = rotation.isupper()
        self._rotate_face(OPERATIONS[rotation.lower()], clockwise)
        self._rotate_edges(OPERATIONS[rotation.lower()], clockwise)

    def _rotate_face(self, face_name: str, clockwise: bool):
        offset = FACE_NAMES.index(face_name) * 9
        for x in range(0, 1):
            for y in range(x, 2 - x):
                temp = self[offset + (x * 3 + y)]
                if clockwise:
                    self[offset + (x * 3 + y)] = self[offset + ((2 - y) * 3 + x)]
                    self[offset + ((2 - y) * 3 + x)] = self[offset + ((2 - x) * 3 + (2 - y))]
                    self[offset + ((2 - x) * 3 + (2 - y))] = self[offset + (y * 3 + (2 - x))]
                    self[offset + (y * 3 + (2 - x))] = temp
                else:
                    self[offset + (x * 3 + y)] = self[offset + (y * 3 + (2 - x))]
                    self[offset + (y * 3 + (2 - x))] = self[offset + ((2 - x) * 3 + (2 - y))]
                    self[offset + ((2 - x) * 3 + (2 - y))] = self[offset + ((2 - y) * 3 + x)]
                    self[offset + ((2 - y) * 3 + x)] = temp

    def _rotate_edges(self, face_name: str, clockwise: bool):
        for a, b, c, d in zip(*ADJACENT_EDGES[face_name]):
            temp = self[a]
            if clockwise:
                self[a] = self[d]
                self[d] = self[c]
                self[c] = self[b]
                self[b] = temp
            else:
                self[a] = self[b]
                self[b] = self[c]
                self[c] = self[d]
                self[d] = temp
